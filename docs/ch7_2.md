[back](ch7.md) | [main menu](../README.md)
 
## 7.2 Model

Program: [M02.java](/ch7_classes/ch7_2_model)

Program M02 produces the output in Figure 7.3. A container is produced which uses a diffuse map, a specular map and an emission map. This is equivalent to an example in the previous chapter, but the coding is different as it makes use of a Model class.

<p align="center">
  <img src="ch7_img/ch7_2_model.png" alt="a container" width="200"><br>
  <strong>Figure 7.3.</strong> Output from M02, a container.
</p>

Program Listing 7.7 gives the part of the glEventListener class that creates the scene and Program Listing 7.8 gives the render method. These are clearly much simplified from previous programs. A cubeModel and a light are declared. The light class needs access to the camera in order to render its mesh correctly. The cubeModel is created using a helper method. Rendering consists of using the relevant render method in each class, i.e. Light and Model. Notice that the Light class also encapsulates the light position and provides a method to set this. getLightPosition is a local glEventListener helper method to animate the light position.

```java
private Model cubeModel;
private Light light;

// textures
private TextureLibrary textures;

public void initialise(GL3 gl) {
  createRandomNumbers();

  textures = new TextureLibrary();
  textures.add(gl, "diffuse_container", "assets/textures/container2.jpg");
  textures.add(gl, "specular_container", "assets/textures/container2_specular.jpg");
  textures.add(gl, "chequerboard", "assets/textures/chequerboard.jpg");
  textures.add(gl, "cloud", "assets/textures/cloud.jpg");
  textures.add(gl, "emission", "assets/textures/matrix.jpg");

  light = new Light(gl, camera);
  cubeModel = makeCube(gl);                             
}
```

**Program Listing 7.7:** Creating the model

```java
public void render(GL3 gl) {
  gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);

  light.setPosition(getLightPosition()); // changing light position each frame

  light.render(gl);
  cubeModel.render(gl);
}
```

**Program Listing 7.8:** Rendering the model

At this high level, all that remains is to define the makeCube helper method. This is given in Program Listing 7.9. A mesh is created by cloning the Cube information. A scale transformation matrix is created> The shader uses the 'dse' fragment shader, indicating that a diffuse map, a specular map and an emission map are required. These are retrieved from the TextureLibrary set up in the initialise method. Next, an instance of the Renderer class is created, which will handle all rendering of the object. Finally, the Model instance is created. This wraps up all the previous classes, as well as links to the light and camera classes.

```java
private Model makeCube(GL3 gl) {
  String name = "cube";
  Mesh mesh = new Mesh(gl, Cube.vertices.clone(), Cube.indices.clone());
  Mat4 modelMatrix = Mat4Transform.scale(4,4,4);
  Shader shader = new Shader(gl, "assets/shaders/vs_standard.txt", 
                                "assets/shaders/fs_standard_dse.txt");
  Material material = MaterialConstants.gold.clone(); 
  //new Material(ambient,diffuse, specular, shininess);
  material.setDiffuseMap(textures.get("diffuse_container"));
  material.setSpecularMap(textures.get("specular_container"));
  material.setEmissionMap(textures.get("emission"));
  Renderer renderer = new Renderer();
  return new Model(name, mesh, modelMatrix, shader, material, renderer, light, camera);
}
```

**Program Listing 7.9:** The helper method makeCube


The Model class is shown in Program Listing 7.10. This contains the attributes to enable a mesh to be transformed and rendered. The render method makes uses of the Renderer instance, passing the required parameters. A second version of render is supplied that can be used to override the transformation stored for the object. This method will be very useful in the next chapter when we introduce scene graphs.

```java
public class Model {
  
  protected String name;
  protected Mesh mesh;
  protected Mat4 modelMatrix;
  protected Shader shader;
  protected Material material;
  protected Camera camera;
  protected Light light;
  protected Renderer renderer;

  //...series of constructors

  //...series of set and get methods for the attributes
  
  public void render(GL3 gl) {
    renderer.render(gl, mesh, modelMatrix, shader, material, light, camera);
  }

  // Second version of render is so that modelMatrix can be overridden with a new parameter.  
  public void render(GL3 gl, Mat4 modelMatrix) {
    if (mesh_null()) {
      System.out.println("Error: null in model render");
      return;
    }
    renderer.render(gl, mesh, modelMatrix, shader, material, light, camera);
  } 
  
  private boolean mesh_null() {
    return (mesh==null);
  }
}
```

**Program Listing 7.10:** The Model class

Program Listing 7.11 gives the Renderer class. Only the render method is shown. Other methods are similar to what has been used in previous programs. These are left as an exercise to read through. The relevant shader (containing links to the vertex and fragment shaders) is set for use. doVertexShaderMatrices passes the model and mvp matrices to the vertex shader. doSingleLight and doBasicMaterial pass the relevant light and object material properties to the fragment shader (even if some of them are not needed, i.e. when texture maps are used). If specific texture maps exist these are then passed to the fragment shader. Finally, the mesh is rendered: inside the Mesh class the relevant vertexArray is bound and the elements are drawn, as per the process described in earlier chapters.

```java
public class Renderer {

  public Renderer() {}

  //...other methods

  public void render(GL3 gl, Mesh mesh, Mat4 modelMatrix,  Shader shader, 
    Material material, Light light, Camera camera) {
    // set shader variables. Be careful that these variables exist in the shader
    shader.use(gl);
    doVertexShaderMatrices(gl, shader, modelMatrix, camera);
    doSingleLight(gl, shader, light);
    doBasicMaterial(gl, shader, material);
    if (material.diffuseMapExists()) {
      Texture dm = material.getDiffuseMap();
      doDiffuseMap(gl, shader, dm);
    }
    if (material.specularMapExists()) {
      Texture sm = material.getSpecularMap();
      doSpecularMap(gl, shader, sm);
    }
    if (material.emissionMapExists()) {
      Texture em = material.getEmissionMap();
      doEmissionMap(gl, shader, em);
    }

    // // then render the mesh
    mesh.render(gl);
  }

}
```

**Program Listing 7.11:** The Renderer class

We now have a working set of classes that can be used to build more complex scenes containing multiple objects each with different materials.



---

## MCQs (written in collaboration with Google Gemini)

GLSL???

---

## Exercises

1. Experiment with changing the material properties of the Cube instance, the instance of TwoTriangles and the Light instance. [Comments]
2. ?????????? There is a commented out line in the render method "//updateLightColour();" Uncomment this and then explain what happens. [Solution]



[back](ch7.md) | [main menu](../README.md)