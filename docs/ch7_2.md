[back](ch7.md) | [main menu](../README.md)
 
## 7.2 Model

Program: [M02.java](/ch7_classes/ch7_2_model)

Program M02 produces the output in Figure 7.3. A container is produced which uses a diffuse map, a specular map and an emission map. This is equivalent to an example in the previous chapter, but the coding is different as it makes use of a Model class.

<p align="center">
  <img src="ch7_img/ch7_2_model.png" alt="a container" width="300"><br>
  <strong>Figure 7.3.</strong> Output from M02, a container.
</p>

Program Listing 7.7 gives the part of the glEventListener class that creates the scene and Program Listing 7.8 gives the render method. These are clearly much simplified from previous programs. A cubeModel and a light are declared. The light class needs access to the camera in order to render its mesh correctly. The cubeModel is created using a helper method. Rendering consists of using the relevant render method in each class, i.e. Light and Model. Notice that the Light class also encapsulates the light position and provides a method to set this. getLightPosition is a local glEventListener helper method to animate the light position.

```java
private Model cubeModel;
private Light light;

// textures
private TextureLibrary textures;

public void initialise(GL3 gl) {
  createRandomNumbers();

  textures = new TextureLibrary();
  textures.add(gl, "diffuse_container", "assets/textures/container2.jpg");
  textures.add(gl, "specular_container", "assets/textures/container2_specular.jpg");
  textures.add(gl, "chequerboard", "assets/textures/chequerboard.jpg");
  textures.add(gl, "cloud", "assets/textures/cloud.jpg");
  textures.add(gl, "emission", "assets/textures/matrix.jpg");

  light = new Light(gl, camera);
  cubeModel = makeCube(gl);                             
}
```

**Program Listing 7.7:** Creating the model

```java
public void render(GL3 gl) {
  gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);

  light.setPosition(getLightPosition()); // changing light position each frame

  light.render(gl);
  cubeModel.render(gl);
}
```

**Program Listing 7.8:** Rendering the model

At this high level, all that remains is to define the makeCube helper method. This is given in Program Listing 7.9. A mesh is created by cloning the Cube information. A scale transformation matrix is created> The shader uses the 'dse' fragment shader, indicating that a diffuse map, a specular map and an emission map are required. These are retrieved from the TextureLibrary set up in the initialise method. Next, an instance of the Renderer class is created, which will handle all rendering of the object. Finally, the Model instance is created. This wraps up all the previous classes, as well as links to the light and camera classes.

```java
private Model makeCube(GL3 gl) {
  String name = "cube";
  Mesh mesh = new Mesh(gl, Cube.vertices.clone(), Cube.indices.clone());
  Mat4 modelMatrix = Mat4Transform.scale(4,4,4);
  Shader shader = new Shader(gl, "assets/shaders/vs_standard.txt", 
                                "assets/shaders/fs_standard_dse.txt");
  Material material = MaterialConstants.gold.clone(); 
  //new Material(ambient,diffuse, specular, shininess);
  material.setDiffuseMap(textures.get("diffuse_container"));
  material.setSpecularMap(textures.get("specular_container"));
  material.setEmissionMap(textures.get("emission"));
  Renderer renderer = new Renderer();
  return new Model(name, mesh, modelMatrix, shader, material, renderer, light, camera);
}
```

**Program Listing 7.9:** The helper method makeCube


The Model class is shown in Program Listing 7.10. This contains the attributes to enable a mesh to be transformed and rendered. The render method makes uses of the Renderer instance, passing the required parameters. A second version of render is supplied that can be used to override the transformation stored for the object. This method will be very useful in the next chapter when we introduce scene graphs.

```java
public class Model {
  
  protected String name;
  protected Mesh mesh;
  protected Mat4 modelMatrix;
  protected Shader shader;
  protected Material material;
  protected Camera camera;
  protected Light light;
  protected Renderer renderer;

  //...series of constructors

  //...series of set and get methods for the attributes
  
  public void render(GL3 gl) {
    renderer.render(gl, mesh, modelMatrix, shader, material, light, camera);
  }

  // Second version of render is so that modelMatrix can be overridden with a new parameter.  
  public void render(GL3 gl, Mat4 modelMatrix) {
    if (mesh_null()) {
      System.out.println("Error: null in model render");
      return;
    }
    renderer.render(gl, mesh, modelMatrix, shader, material, light, camera);
  } 
  
  private boolean mesh_null() {
    return (mesh==null);
  }
}
```

**Program Listing 7.10:** The Model class

Program Listing 7.11 gives the Renderer class. Only the render method is shown. Other methods are similar to what has been used in previous programs. These are left as an exercise to read through. The relevant shader (containing links to the vertex and fragment shaders) is set for use. doVertexShaderMatrices passes the model and mvp matrices to the vertex shader. doSingleLight and doBasicMaterial pass the relevant light and object material properties to the fragment shader (even if some of them are not needed, i.e. when texture maps are used). If specific texture maps exist these are then passed to the fragment shader. Finally, the mesh is rendered: inside the Mesh class the relevant vertexArray is bound and the elements are drawn, as per the process described in earlier chapters.

```java
public class Renderer {

  public Renderer() {}

  //...other methods

  public void render(GL3 gl, Mesh mesh, Mat4 modelMatrix,  Shader shader, 
    Material material, Light light, Camera camera) {
    // set shader variables. Be careful that these variables exist in the shader
    shader.use(gl);
    doVertexShaderMatrices(gl, shader, modelMatrix, camera);
    doSingleLight(gl, shader, light);
    doBasicMaterial(gl, shader, material);
    if (material.diffuseMapExists()) {
      Texture dm = material.getDiffuseMap();
      doDiffuseMap(gl, shader, dm);
    }
    if (material.specularMapExists()) {
      Texture sm = material.getSpecularMap();
      doSpecularMap(gl, shader, sm);
    }
    if (material.emissionMapExists()) {
      Texture em = material.getEmissionMap();
      doEmissionMap(gl, shader, em);
    }

    // // then render the mesh
    mesh.render(gl);
  }

}
```

**Program Listing 7.11:** The Renderer class

We now have a working set of classes that can be used to build more complex scenes containing multiple objects each with different materials.

---

## Exercises

1. Experiment with changing the material properties of the Cube instance, the instance of TwoTriangles and the Light instance. [Comments]
2. ?????????? There is a commented out line in the render method "//updateLightColour();" Uncomment this and then explain what happens. [Solution]

---

## MCQs (written in collaboration with Google Gemini)

<p>1. Based on the provided text, what is the primary role of the new Model class?</p>
<details>
<summary>a) To handle the drawing of the mesh on the screen.</summary>
<p><b>Incorrect.</b> The Renderer class is responsible for the actual drawing (rendering) of the mesh.</p>
</details>
<details>
<summary>b) To encapsulate all the components needed to define and render an object, such as the mesh, material, and transformations.</p>
<p><b>Correct.</b> The text states that the Model instance "wraps up all the previous classes" and contains attributes for the mesh, its transformation matrix, shader, material, light, and camera.</p>
</details>
<details>
<summary>c) To create the texture maps used by the object.</summary>
<p><b>Incorrect.</b> The TextureLibrary and Material classes handle the textures, while the Model class just holds a reference to the Material.</p>
</details>
<details>
<summary>d) To directly pass the model and view matrices to the vertex shader.</summary>
<p><b>Incorrect.</b> The Renderer class has a specific method doVertexShaderMatrices for this purpose. The Model class holds the modelMatrix but relies on the Renderer to handle the shader communication.</p>
</details>

---

<p>2. In the render method of the Model class, why is there a second version that accepts a Mat4 parameter?</p>
<details>
<summary>a) To allow the user to change the color of the model's material at runtime.</summary>
<p><b>Incorrect.</b> The parameter is a Mat4 (a matrix), not a color. This parameter is used to change the model's transformation matrix, which affects its position, rotation, and scale.</p>
</details>
<details>
<summary>b) To provide a way to animate the object's movement over time.</summary>
<p><b>Incorrect.</b> While this method could be used in an animation loop, its primary purpose, as stated in the text, is to "override the transformation stored for the object."</p>
</details>
<details>
<summary>c) To allow a different transformation matrix to be used for rendering without changing the one stored in the Model instance.</summary>
<p><b>Correct.</b> The text explains that this second render method can "override the transformation stored for the object," making it useful for things like scene graphs where an object's position might be determined by a parent object's transformation.</p>
</details>
<details>
<summary>d) To change the shader being used to render the model.</summary>
<p><b>Incorrect.</b> The Mat4 parameter is for the model matrix. The shader is a separate attribute of the Model instance and is not affected by this parameter.</p>
</details>

[back](ch7.md) | [main menu](../README.md)