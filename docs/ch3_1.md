[back](ch3.md) | [main menu](../README.md)
 
## 3.1 The basics of shaders

This section builds on the initial discussion of shaders in the last chapter and discusses the kinds of data we can transfer from the CPU to the GPU and between shaders on the GPU. 

### 3.1.1 The ins and outs (attributes) of shaders

This program is similar to the programs we looked at in Chapter 2, as illustrated in Program Listing 3.1. We're still including everything to do with OpenGL in one class and we're still using an EBO, but only one triangle is used (Figure 3.1). However, now we're ready to 'get under the hood' and explain Ã¬n more detail what is happening with regards shaders on the GPU.

```java
  import java.nio.*;
  import com.jogamp.common.nio.*;
  import com.jogamp.opengl.*;
  import com.jogamp.opengl.util.*;
  import com.jogamp.opengl.util.awt.*;
  import com.jogamp.opengl.util.glsl.*;
  
  public class S01_GLEventListener implements GLEventListener {
  
  public S01_GLEventListener() {
  }
  
  // ***************************************************
  /*
    * METHODS DEFINED BY GLEventListener
    */
  
  public void init(GLAutoDrawable drawable) {
  }
  
  public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {
  }
  
  public void display(GLAutoDrawable drawable) {
  }
  
  public void dispose(GLAutoDrawable drawable) {
  }
  
  // *************************************************** 
  /* THE SCENE */
  
  // ***************************************************
  /* THE DATA */
  
  // ***************************************************
  /* THE BUFFERS */
  
  // ***************************************************
  /* THE SHADER */
  
  }
```

**Program Listing 3.1:** S01_GLEventListener.java

Program Listing 3.2 shows the shaders we will consider. These are stored as String variables. Later we will see how to load these from text files, which will produce a more flexible process since these can then be edited in any text editor.

```java
// ***************************************************
/* THE SHADER
  */

private String vertexShaderSource = 
  "#version 330 core\n" +
  "\n" +
  "layout (location = 0) in vec3 position;\n" +
  "\n" +
  "out vec4 aColor;\n" +       // colour is passed to rasterisation process
  "\n" +
  "void main() {\n" +
  "  gl_Position = vec4(position.x, position.y, position.z, 1.0);\n" +
  "  aColor = vec4(0.55f, 0.0f, 0.55f, 1.0f);\n" +     // vertex colour is set here
                                                        // - a shade of magenta
  "}";

private String fragmentShaderSource = 
  "#version 330 core\n" +
  "\n" +
  "out vec4 fragColor;\n" +
  "\n" +
  "in vec4 aColor;\n" +        // colour received from rasterisation process
  "\n" +
  "void main() {\n" +
  "  fragColor = aColor;\n" +  // output colour for fragment set to input colour
  "}";
```

**Program Listing 3.2a:** The shaders as listed in the program code

```glsl
#version 330 core

layout (location = 0) in vec3 position;
out vec4 aColor;

void main() {
  gl_Position = vec4(position.x, position.y, position.z, 1.0);
  aColor = vec4(0.55f, 0.0f, 0.55f, 1.0f);
}
```

**Program Listing 3.2b:** The vertex shader

```glsl
#version 330 core

out vec4 fragColor;
in vec4 aColor;

void main() {
  fragColor = aColor;
}
```

**Program Listing 3.2c:** The fragment shader

The GPU pipeline takes the sequence of vertices which describe triangles, manipulates each vertex with a separate instance of the vertex shader (all running in parallel, subject to available resources), then rasterises groups of three vertices making up a triangle to produce the set of fragments for a triangle. Rasterisation means that the values at the vertices of the triangle are bilinearly interpolated over the triangle to produce values for each fragment. For example, the vertex positions are bilinearly interpolated to produce the screen positions for each fragment.

In previous programs, the colour of a fragment was set to a specific (red, green, blue, alpha) value in the fragment shader. Since the same fragment shader was run for each fragment a triangle was rasterised into, every pixel in the triangle was the same colour. In Program Listing 3.2, the colour is instead set in the vertex shader and declared as an out variable with a matching in variable in the fragment shader. As an out variable, it is subject to the GPU's rasterisation process. In this case, since every vertex is set to the same colour, the rasterisation process will produce the same colour for each fragment!! We need a way to set each vertex to a different colour.

Consider the shader attributes in Program Listing 3.2. The keyword in indicates that data (attributes) is being transferred into a vertex shader or a fragment shader. The keyword out indicates that data (attributes) is being transferred to the next stage in the GPU's pipeline. The line #version 330 core indicates that the default core GLSL (GL Shading Language) version 3.30 is being used. 

In GLSL, the preferred method of defining the location of vertex attributes on the GPU is using layout(location = x). Thus the following line states that the vertex shader is expecting the vertex position to be defined in location 0: 

```glsl
layout (location = 0) in vec3 position
```

Any variable name could have been chosen. I used position since it indicates what the variable contains. I'll use the same name for this in every program. Within the body of the vertex shader, the variable glPosition (of type vec4) is set to a value. This is one of a small number of pre-defined variables on the GPU. This value must be set in the vertex shader and it is then automatically sent on to the next stage of the GPU pipeline. We do not have to state that it is an 'out' variable.

The vertex colour is also set in the vertex shader. The variable aColor (which I shall use in all subsequent programs) is used to store this: 

```glsl
gl_Position = vec4(position.x, position.y, position.z, 1.0);
aColor = vec4(0.55f, 0.0f, 0.55f, 1.0f);
```

We explicitly state that we want this value (attribute) to be passed on to the next stage in the GPU pipeline by using the keyword out (out vec4 aColor;) when we declare the variable in the vertex shader. 

The rasterisation stage then takes the positions and colours of three vertices (the GPU automatically handles the association using the index buffer) and creates the fragments of the triangle they define. Since the colour that is set in the vertex shader is a specific literal value and every vertex is set to the same colour value, then the rasterisation process will interpolate three vertices with the same colour value and thus each fragment will be the same colour. However, as we shall soon see, there is a way to set different colour values for each vertex.

In the fragment shader, the keyword 'in' states that a colour is input to the fragment shader. Important: the variable name, aColor is the same as the variable name declared as an 'out' variable in the vertex shader. The keyword 'out' indicates that the fragment shader produces an output colour. In this example, the body of the fragment shader simply sets the output attribute to the value of the input attribute.

It is worth noting at this stage that the main program running on the CPU is sending the following data to the GPU:

```java
private float[] vertices = {
     -0.5f, -0.5f, 0.0f,  // Bottom Left
      0.5f, -0.5f, 0.0f,  // Bottom Right
      0.0f,  0.5f, 0.0f   // Top middle
};

private int[] indices = {
    0, 1, 2
};
```

Only vertex position data is being sent. We could also send other data to the GPU, e.g. colours for each of the vertices. These are per-vertex attributes, which we'll look at later. First, we'll look at how to use 'uniforms'.

### 3.1.2 Uniforms

Uniforms can be used to pass data from the CPU application to the shaders on the GPU. A uniform can be accessed by either the vertex or fragment shader in the shader program object. The same uniform constant is available to every instance of the vertex and fragment shaders launched by a render call (e.g. glDrawElements()). Uniforms can be changed before subsequent render calls. Figures 3.2 and 3.3 show what can be done by changing the value of a uniform representing the triangle colour before each call to render the triangle.

<p align="center">
  <img src="img_ch2/A03_output.png" alt="output from A03" width="100">&nbsp;<img src="img_ch2/A03_wireframe.jpg" alt="output from A03" width="100"><br>
  <strong>Figure 2.2.</strong> (a) Two triangles; (b) The edges of two triangles.
</p>

<p align="center">
  <img src="img_ch3/S02a_triangle.jpg" alt="A triangle" width="300"><br>
    <img src="img_ch3/S02b_triangle.jpg" alt="Another triangle" width="300"><br>
  <strong>Figure 3.2</strong> (a) A triangle (b) Another triangle
</p>



