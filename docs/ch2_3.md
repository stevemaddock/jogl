[back](ch2.md) | [main menu](../README.md)

## 2.3 Element Buffer Objects

The previous section looked at how to draw a single triangle. The exercises looked at how to extend this to to draw two triangles. However, this involved repeating data. In this section, Element Buffer Objects (EBOs) are used to draw multiple triangles, without the need to repeat vertex data.

Joey de Vries's Hello Triangle example discusses Element Buffer Objects (EBOs). You should read through this before proceeding

<p align="center">
  <img src="img_ch2/ebo_two_triangles.jpg" alt="two triangles" width="100"><br>
  <strong>Figure 2.10.</strong> Two triangles
</p>

Program A03.java uses EBOs to render two triangles, to produce a rectangle, as illustrated in Figure 2.10. (Figure 2.12 shows the edges of the triangles.) The changes to the programs in Section 2.2 are mainly confined to the data section and the methods fillBuffers() and render(). Program Listing 2.11 gives the data section and Program Listing 2.12 gives the fillBuffers() method.

```
// ***************************************************
/* THE DATA
  */

// Two triangles to make a rectangle.
  
private float[] vertices = {      // x,y,z,
    -0.5f,  0.5f, 0.0f,           // Top Left 
    -0.5f, -0.5f, 0.0f,           // Bottom Left
      0.5f, -0.5f, 0.0f,           // Bottom Right
      0.5f,  0.5f, 0.0f,           // Top Right
};  

private int[] indices = {         // Note that we start from 0
    0, 1, 2,                      // First Triangle
    0, 2, 3                       // Second Triangle
};
```

**Program listing 2.11:** The data

In Program Listing 2.11, we can see that four vertices are listed to describe two triangles. The array indices describes how to make use of the vertices to create the two triangles.

Program Listing 2.12 introduces a new kind of buffer, the element buffer (elementBufferId), to store the indices that describe the triangles - you might like to plot the triangles on a piece of paper to check your understanding. Otherwise, the method fillBuffers() is similar to the one in Section 2.2. Some variables have also been introduced to replace literal values.

```
// ***************************************************
/* THE BUFFERS
  */

private int[] vertexBufferId = new int[1];
private int[] vertexArrayId = new int[1];
private int[] elementBufferId = new int[1];                          /* new */

private void fillBuffers(GL3 gl) { 
  gl.glGenVertexArrays(1, vertexArrayId, 0);
  gl.glBindVertexArray(vertexArrayId[0]);
  
  gl.glGenBuffers(1, vertexBufferId, 0);
  gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vertexBufferId[0]);

  FloatBuffer fb = Buffers.newDirectFloatBuffer(vertices);

  gl.glBufferData(GL.GL_ARRAY_BUFFER, Float.BYTES * vertices.length,
                  fb, GL.GL_STATIC_DRAW);

  int stride = 3;                                                   /* new */
  int numVertexFloats = 3;                                          /* new */
  int offset = 0;                                                   /* new */
  gl.glVertexAttribPointer(0, numVertexFloats, GL.GL_FLOAT, false,  /* changed to */
                            stride*Float.BYTES, offset);             /* use variables */
  gl.glEnableVertexAttribArray(0);
  
  gl.glGenBuffers(1, elementBufferId, 0);                           /* new */
                                  
  IntBuffer ib = Buffers.newDirectIntBuffer(indices);               /* new */
  gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, elementBufferId[0]);  /* new */
  gl.glBufferData(GL.GL_ELEMENT_ARRAY_BUFFER,                       /* new */
                  Integer.BYTES * indices.length, ib, GL.GL_STATIC_DRAW);
  gl.glBindVertexArray(0);
}
```

**Program listing 2.12:** Setting up the buffers with the addition of EBOs

Program listing 2.13 shows the changes necessary to the render() method to use EBOs. The render method from Section 2.2 is shown in Program Listing 2.14 for comparison purposes - only one line is different. 

```
// ***************************************************
/* THE SCENE
  * Now define all the methods to handle the scene.
  */

public void initialise(GL3 gl) {
  initialiseShader(gl);
  shaderProgram = compileAndLink(gl);
  fillBuffers(gl);
}

public void render(GL3 gl) {
  gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);
  gl.glUseProgram(shaderProgram);
  gl.glBindVertexArray(vertexArrayId[0]);
  gl.glDrawElements(GL.GL_TRIANGLES, indices.length, GL.GL_UNSIGNED_INT, 0);   /* new */
  gl.glBindVertexArray(0);  
}
```

**Program listing 2.13:** Using EBOs for rendering

```
public void render(GL3 gl) {
  gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);
  gl.glUseProgram(shaderProgram);
  gl.glBindVertexArray(vertexArrayId[0]);
  gl.glDrawArrays(GL.GL_TRIANGLES, 0, 3);                        /* drawing one triangle */
  gl.glBindVertexArray(0);
}
```

**Program listing 2.14:** The render method from Section 2.2 - compare this with Program Listing 2.13. The only change is the method used to draw the data.

You should be able to work out what is going on in the JOGL code by following Joey's example. As I have said previously, a lot of the code for dealing with GPUs can be copied from one program to the next, even with more vertices to deal with. We will see this in subsequent sections. We'll make use of EBOs in subsequent programs.

<p align="center">
  <img src="img_ch2/ch2_11_on_the_gpu.png" alt="Multiple copies of the shaders handle the data on the GPU" width="500"><br>
  <strong>Figure 2.11.</strong> Multiple copies of the shaders handle the data on the GPU
</p>

Figure 2.11 is an updated version of Figure 2.9 from section 2.2. It shows that we now have an EBO on the GPU that stores the index data. The vertex data is bound to this index data - see Program Listing 2.13. The GPU makes use of this information to decide how many copies of the vertex shader to make as it deals with the data in its buffers.

<p align="center">
  <img src="img_ch2/ebo_two_triangles_wireframe.jpg" alt="Two wireframe triangles" width="100"><br>
  <strong>Figure 2.12.</strong> Two wireframe triangles
</p>

---

## Exercises

1. Instead of filling the triangle that is drawn, a 'wireframe' of it can be drawn by configuring OpenGL to draw lines for the edges of triangles instead of filling the triangles (Figure 2.12). This is done inside method init(), where other OpenGL attributes are also similarly configured, e.g. setting the background clear colour. The C version for achieving this is: glPolygonMode(GL_FRONT_AND_BACK, GL_LINE). The equivalent JOGL version of this is gl.glPolygonMode(GL.GL_FRONT_AND_BACK, GL3.GL_LINE); Add this to the method init() to see the effect on drawing the triangle. (Note: some OpenGL attributes can be referred to in JOGL using GL.XYZ. This applies to attributes that have been available in all previous versions of OpenGL. However, some require a specific OpenGL profile to be used, e.g. GL3.GL_LINE. In most cases, you can resort to just using GL3.XYZ for all of them, unless you are using a later OpenGL 4.x profile.) The default (C version) is glPolygonMode(GL_FRONT_AND_BACK, GL_FILL).
2. Change the program to draw three triangles. [Solution.] (Hint: it might be easier to see what is happening if you draw the outlines of the triangles, as in Figure 2.12.) (We'll look at how to change the colour of the triangles in the next chapter.)
3. (Advanced): Look through the solutions for exercises 2 and 3 in Joey's triangle tutorial. You do not have to implement these in Java and JOGL. We'll look at similar examples in later chapters.

