[back](ch3.md) | [main menu](../README.md)

## 3.2 Dynamically changing the VBO data

Program: [S04.java](/ch3_shaders)

This example shows how to change the data for a vertex whilst the program is running. This could be done by (i) changing the vertex data for one or more vertices on the CPU and then sending all the vertex data to the GPU for each iteration of the display loop, or (ii) sending all the vertex data once and then 'reaching over' to the GPU and altering the data for some (or all) of the vertices on the GPU during the display loop. The second option means that we don't have to keep sending all the data (although we still have to send the changed data). Figure 3.4 illustrates the results of changing all the vertex positions over time. A similar approach could be used to change a subset of a collection of vertices. (We'll see in later chapters that we instead use matrices to manipulate, i.e. transform, collections of vertices for 3D objects.)

<p align="center">
  <img src="ch3_img/S04_triangle.gif" alt="A changing triangle" width="300"><br>
  <strong>Figure 3.4</strong> A changing triangle
</p>

Program Listing 3.10 gives a method to change the xyz position value of a single vertex and a method to change the colour value of a single vertex. The first method uses the index of the vertex in the list multiplied by the stride to access the specific vertex in the list of vertex data. The second method uses a modified version that takes into account that the colour values come after the xyz position values in the set of values for a single vertex. Thus vertexXYZFloats = 3 (the number of floats in the xyz position data) is required. The render method is updated accordingly to make use of the method to change the values (see Program Listing 3.11). 

The two methods in Program Listing 3.10 are very similar and both rely on particular class attributes. It would be possible to rewrite them to improve on efficiency, readability and maintainability. For example, the parameters of the second method could be r, g and b, rather than x, y and z to improve readability/understandability. However, I have written them in this way to make the similarities of the two methods clear to focus on what is happening when accessing the data on the GPU. 

Note: In previous versions of fillbuffers(), glBufferData() has been using GL.GL_STATIC_DRAW when setting up the buffer for the vertex data. Now that the data is changing with every call to render, this is changed to GL.GL_DYNAMIC_DRAW.

```java
private void replaceVBO_XYZ(GL3 gl, int index, float x, float y, float z) {
  float[] aVertex = {x,y,z};
  gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vertexBufferId[0]);
  FloatBuffer fb = Buffers.newDirectFloatBuffer(aVertex);
  gl.glBufferSubData(GL.GL_ARRAY_BUFFER, 
                      Float.BYTES * index * vertexStride, 
                      Float.BYTES * aVertex.length, fb);
  gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0);
}

private void replaceVBO_RGB(GL3 gl, int index, float x, float y, float z) {
  float[] aVertex = {x,y,z};
  gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vertexBufferId[0]);
  FloatBuffer fb = Buffers.newDirectFloatBuffer(aVertex);
  gl.glBufferSubData(GL.GL_ARRAY_BUFFER, 
                      Float.BYTES * (index * vertexStride + vertexXYZFloats), // *** difference
                      Float.BYTES * aVertex.length, fb);
  gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0);
}
```

**Program Listing 3.10:** Changing the xyz position and colour values of a single vertex in the relevant GPU buffer

Program Listing 3.11 makes use of the methods from Program Listing 3.10 to alter all three vertices of a triangle during the display loop. The XYZ position of each vertex is altered by making use of the elapsedTime variable. Variations of sin and cos are used to alter each vertex differently (so as to keep values in the range 0 to 1).

Note: there is no error checking in Program Listing 3.10, so the calling method in Program Listing 3.11 must supply a valid vertex index (i.e. 0, 1 or 2, in this case) or the program will crash.


```java
public void render(GL3 gl) {
  gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);
  double elapsedTime = getSeconds() - startTime;
  replaceVBO_XYZ(gl, 0, (float)Math.sin(elapsedTime), (float)Math.cos(elapsedTime), 0);
  replaceVBO_XYZ(gl, 1, (float)Math.sin(elapsedTime)*0.5f,
                        (float)Math.cos(elapsedTime)*0.5f, 0);
  replaceVBO_XYZ(gl, 2, (float)Math.cos(elapsedTime*0.5),
                        (float)Math.sin(elapsedTime*0.5), 0);
  gl.glUseProgram(shaderProgram);
  gl.glBindVertexArray(vertexArrayId[0]);
  gl.glDrawElements(GL.GL_TRIANGLES, indices.length, GL.GL_UNSIGNED_INT, 0);
  gl.glBindVertexArray(0);   // can be omitted
}
```

**Program Listing 3.11:** render()

---

## Exercises

1. Experiment with changing the rgb colour values of the vertices, in addition to the xyz values. (Hint: This can be done by calling replaceVBO_RGB.)


---

## MCQs (written in collaboration with Google Gemini)


<p>1. When should you generally consider using a dynamic VBO instead of a static one?</p>

<details>
<summary>a) When the vertex data for an object never changes after its initial creation.</summary>
<p><b>Incorrect.</b> If the vertex data never changes, a static VBO (GL_STATIC_DRAW) is the appropriate choice. This hint allows the OpenGL driver to place the data in memory optimized for read-only access and high rendering performance, as it doesn't expect updates.</p>
</details>

<details>
<summary>b) When the vertex data is very small and fits entirely in the CPU cache.</summary>
<p><b>Incorrect.</b> The size of the data and its fit in the CPU cache is less relevant to the dynamic/static VBO decision. The primary consideration is how often the data will be modified. Even small data, if frequently updated, benefits from dynamic VBOs.</p>
</details>

<details>
<summary>c) When the vertex data is expected to change frequently (e.g., every frame or every few frames).</summary>
<p><b>Correct.</b> This is the ideal scenario for using a dynamic VBO. The GL_DYNAMIC_DRAW usage hint tells the OpenGL driver that the data in the VBO will be updated often by the CPU. This allows the driver to make optimizations, such as placing the VBO in memory regions that are faster for frequent writes from the CPU, even if it means slightly slower reads by the GPU compared to static buffers.</p>
</details>

<details>
<summary>d) When you need to store non-vertex specific data like uniform values or texture coordinates.</summary>
<p><b>Incorrect.</b> While texture coordinates are indeed vertex attributes and would go into a VBO, uniform values are stored in Uniform Buffer Objects (UBOs) or passed as individual uniforms, not in VBOs. The question's focus is on when to use a dynamic VBO specifically, which is tied to the frequency of vertex data updates.</p>
</details>

---

<p>2. A JOGL application is displaying a deformable mesh, such as a flag waving in the wind. The vertex positions of this mesh need to be updated every frame to simulate the movement. Which of the following OpenGL functions is most commonly and efficiently used in the rendering loop to update a pre-allocated dynamic VBO with new vertex data for this animation?</p>

<details>
<summary>a) gl.glBufferData(target, size, data, usage) to entirely re-allocate and fill the VBO.</summary>
<p><b>Incorrect.</b> While glBufferData can be used to update a VBO, calling it repeatedly in a rendering loop to re-allocate the entire buffer is generally inefficient, especially for frequent updates. It often involves discarding the old data store and allocating a new one, which can introduce performance overhead.</p>
</details>

<details>
<summary>b) gl.glGenBuffers() to create a brand new VBO for each frame.</summary>
<p><b>Incorrect.</b> Creating new buffer objects (glGenBuffers) and then immediately deleting them (glDeleteBuffers) every frame would be extremely inefficient. Object creation and destruction on the GPU are costly operations and should be minimized in a real-time rendering loop. You want to reuse resources as much as possible.</p>
</details>

<details>
<summary>c) gl.glBufferSubData(target, offset, size, data) to update a portion of the existing VBO.</summary>
<p><b>Correct.</b> This is the most common and efficient method for updating a pre-allocated dynamic VBO with new data, especially when only a part of the buffer (or even the whole buffer) needs to be modified, but its size remains constant. glBufferSubData allows you to upload new data into a specified range of an existing buffer's data store without re-allocating the entire buffer, which minimizes overhead and maximizes performance for dynamic geometry.</p>
</details>

<details>
<summary>d) gl.glDeleteBuffers() followed by gl.glBufferData() for every update.</summary>
<p><b>Incorrect.</b> This approach combines the inefficiencies of options A and B. Deleting and then recreating a VBO every frame is highly detrimental to performance due to constant memory allocation/deallocation and object management overhead. This is generally avoided in real-time applications.</p>
</details>

[back](ch3.md) | [main menu](../README.md)