[back](ch9.md) | [main menu](../README.md)
 
## 9.1 Multiple lights

Program: [ML01.java](/ch9_extras/ch9_1_multiple_lights)

This example uses three intersecting cuboids surrounded by three moving coloured lights, as shown in Figure 9.1.

<p align="center">
  <img src="ch9_img/ch9_1_multiple_lights.png" alt="three cubes and three lights" width="200"><br>
  <strong>Figure 9.1.</strong> Three cubes and three lights.
</p>

The classes we have been using are written to handle one light. Methods feature a single light in their parameter list. Many of these must be changed to a list of lights. Here, we will use an array. Program Listing 9.1 sets up three lights, each with different properties. makeCube uses the class variable lights when creating a Model instance. Thus the Model class is changed to accommodate multiple lights. The key parts, shown in Program Listing 9.2, are that it stores the lights and passes them to the the render method.

```java
private Model[] cube;
private Light[] lights;

private TextureLibrary textures;

public void initialise(GL3 gl) {
  // set up textures first

  lights = new Light[3];

  lights[0] = new Light(gl, camera);
  lights[0].setMaterial(MaterialConstants.gold.clone());

  lights[1] = new Light(gl, camera);
  lights[1].setMaterial(MaterialConstants.brightWhiteLightSource.clone());

  lights[2] = new Light(gl, camera);
  lights[2].setMaterial(MaterialConstants.cyanPlastic.clone());

  // create cubes
}

// ...

private Model makeCube(GL3 gl, Mat4 m, String fragmentPath, Texture diffuse, Texture specular, Texture emission) {
  // ...
  return new Model(name, mesh, modelMatrix, shader, material, renderer, lights, camera);
}
```

**Program Listing 9.1:** Initialising the scene

```java
public class Model {
  //...
  protected Light[] lights;
  //...

  public void render(GL3 gl) {
    renderer.render(gl, mesh, modelMatrix, shader, material, lights, camera);
  }
  //...
}
```

**Program Listing 9.2:** Model.render with an array of lights


Program Listing 9.3 updates the position of each light and then renders the lights and cubes. This calls the Model.render method, which in turn calls the Renderer.render method. Program Listing 9.4 shows the changes to this.

```java
public void render(GL3 gl) {
  gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);

  lights[0].setPosition(getLight0Position()); // changing light position each frame
  lights[1].setPosition(getLight1Position()); // changing light position each frame
  lights[2].setPosition(getLight2Position()); // changing light position each frame

  lights[0].render(gl);
  lights[1].render(gl);
  lights[2].render(gl);
  
  cube[0].render(gl);
  cube[1].render(gl);
  cube[2].render(gl);
}
```

**Program Listing 9.3:** ML01_GLEventListener.render

```java
public class Renderer {

  //...

  private void doMultipleLights(GL3 gl, Shader shader, Light[] lights) {
    shader.setInt(gl,"numLights", lights.length);
    for (int i=0; i<lights.length; i++) {
      shader.setVec3(gl, "lights["+i+"].position", lights[i].getPosition());
      shader.setVec3(gl, "lights["+i+"].ambient", lights[i].getMaterial().getAmbient());
      shader.setVec3(gl, "lights["+i+"].diffuse", lights[i].getMaterial().getDiffuse());
      shader.setVec3(gl, "lights["+i+"].specular", lights[i].getMaterial().getSpecular());
    }
  }

  //...

  public void render(GL3 gl, Mesh mesh, Mat4 modelMatrix,  Shader shader, 
                     Material material, Light[] lights, Camera camera) {
    //...

    //doSingleLight(gl, shader, light);
    doMultipleLights(gl, shader, lights);
    //...

    // then render the mesh
    mesh.render(gl);
  }

}
```

**Program Listing 9.4:** Renderer.render

The main change to Renderer.render (Program Listing 9.4) is the introduction of a new method to handle an array of lights rather than a single light. This relies on the shaders being able to handle multiple lights. Program Listing 9.5 shows the fs_standard_dse_ml.txt shader which is an update of the standard dse shader. An array of lights is declared and used in the shader. Renderer.render's doMultipleLights method sets these values. A maximum of 10 lights can be used.

In the shader a main method is used with a loop to call CalcPointLight for each light used. One could see this being extended to cope with other kinds of lights, e.g. directional lights or spotlights. The Java programs would need to have different kinds of lights, perhaps using Light as a base class, and then the Renderer.render method would need to be rewritten to deal with setting the different kinds of lights in the appropriate shader.

```glsl
#version 330 core

in vec3 aPos;
in vec3 aNormal;
in vec2 aTexCoord;

out vec4 fragColor;

uniform vec3 viewPos;
uniform sampler2D diffuse_texture;
uniform sampler2D specular_texture;
uniform sampler2D emission_texture;

struct Light {
  vec3 position;
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;
};

#define MAX_POINT_LIGHTS 10  
uniform Light lights[MAX_POINT_LIGHTS];
uniform int numLights;

struct Material {
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;
  float shininess;
}; 
  
uniform Material material;

vec3 CalcPointLight(Light light, vec3 norm, vec3 aPos, vec3 viewDir) {
  // ambient
  // change so only one ambient used in main method?
  // or divide by number of lights?
  // or leave to user to deal with
  vec3 ambient = light.ambient * vec3(texture(diffuse_texture, aTexCoord)) * 1.0/float(numLights);

  // diffuse
  vec3 lightDir = normalize(light.position - aPos);  
  float diff = max(dot(norm, lightDir), 0.0);
  vec3 diffuse = light.diffuse * diff * vec3(texture(diffuse_texture, aTexCoord));
  
  // specular 
  vec3 reflectDir = reflect(-lightDir, norm);  
  float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
  vec3 specular = light.specular * spec * vec3(texture(specular_texture, aTexCoord));
 
  vec3 result = ambient + diffuse + specular;
  return result;
}

void main() {
  vec3 norm = normalize(aNormal);
  vec3 viewDir = normalize(viewPos - aPos);

  vec3 result = vec3(0.0);
  for(int i = 0; i < numLights; i++)
    result += CalcPointLight(lights[i], norm, aPos, viewDir); 

  vec3 emission = vec3(texture(emission_texture, aTexCoord));

  result = result + emission;
  fragColor = vec4(result, 1.0);
}
```

**Program Listing 9.5:** fs_standard_dse_ml.txt

---

## MCQs (written in collaboration with Google Gemini)

<p>1. Based on the provided code and text, what is the key change made to the Renderer class to accommodate multiple lights?</p>
<details>
<summary>a) The render method's parameter list was changed to accept a Light array instead of a single Light object, and it now calls doMultipleLights.</summary>
<p><b>Correct.</b> Program Listing 9.4 shows that the render method signature was updated from Light light to Light[] lights, and it now calls doMultipleLights while the previous doSingleLight call is commented out. This is the main change described in the text.</p>
</details>
<details>
<summary>b) The Renderer class now stores an array of Light objects as a member variable.</summary>
<p><b>Incorrect.</b> The Model class, not the Renderer, stores the Light array. The Renderer receives the array as a parameter to its render method.</p>
</details>
<details>
<summary>c) It was updated to handle different types of lights, such as directional lights and spotlights.</summary>
<p><b>Incorrect.</b> The text mentions this as a possible future extension, but the provided code for Renderer.render and doMultipleLights only shows how to handle an array of point lights.</p>
</details>
<details>
<summary>d) The doMultipleLights method calculates the ambient, diffuse, and specular components for all lights and stores them in a single Vec3 array.</summary>
<p><b>Incorrect.</b> The doMultipleLights method passes the properties of each light individually to the shader using a loop. The shader then sums the contributions from each light.</p>
</details>


[back](ch9.md) | [main menu](../README.md)