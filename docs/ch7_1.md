[back](ch7.md) | [main menu](../README.md)
 
## 7.1 Material

Program: [M01.java](/ch7_classes/ch7_1_material)

The aim is to move all the attributes related to the material properties of an object into a separate Material class. The first example, M01, produces the result in Figure 7.2.  A cube is declared along with an associated cubeMaterial. At this stage no texture maps are used in the program. A light is also declared to be a Mesh with associated lightMaterial. In section 7.2 we'll see these combined into a Model class. For now, we're proceeding a steady pace and slowly increasing the number of classes so the development from previous programs is easier to follow. 

As no texture maps are used in this program, shaderCube is set to use the basic fragment shader fs_standard_0t.txt (Program Listing 7.1). The light makes use of a constant to set its material properties. The collection of material constants is defined in a class called MaterialConstants. These are defined as final instances, so a clone is used to create an instance that can subsequently be changed. Program Listing 7.2 shows some of the Material class and Program Listing 7.3 shows some of the MaterialConstants class.

<p align="center">
  <img src="ch7_img/ch7_1_material.png" alt="a plain cube" width="200"><br>
  <strong>Figure 7.2.</strong> Output from M01, a plain cube.
</p>


```java
private Mesh cube;
private Mesh light;
private Material cubeMaterial;
private Vec3 lightPosition = new Vec3(4f,5f,8f);
private Material lightMaterial;

public void initialise(GL3 gl) {
  cube = new Mesh(gl, Cube.vertices, Cube.indices);
  light = new Mesh(gl, Sphere.vertices, Sphere.indices);

  cubeMaterial = new Material(new Vec3(1.0f, 0.5f, 0.31f), 
                              new Vec3(1.0f, 0.5f, 0.31f), 
                              new Vec3(0.5f, 0.5f, 0.5f), 
                              32.0f);
  shaderCube = new Shader(gl, "assets/shaders/vs_standard.txt", 
                              "assets/shaders/fs_standard_0t.txt");

  lightMaterial = MaterialConstants.dullWhiteLightSource.clone();
  shaderLight = new Shader(gl, "assets/shaders/vs_light_01.txt", 
                                "assets/shaders/fs_light_01.txt");
}
```

**Program Listing 7.1:** Initialising a cube and a light, which make use of Material for the material properties.

```java
public class Material implements Cloneable {
  
  // Default is a fairly bright white colour with some specular.
  public static final Vec3 DEFAULT_AMBIENT = new Vec3(0.2f, 0.2f, 0.2f);
  public static final Vec3 DEFAULT_DIFFUSE = new Vec3(0.8f, 0.8f, 0.8f);
  public static final Vec3 DEFAULT_SPECULAR = new Vec3(0.5f, 0.5f, 0.5f);
  public static final Vec3 DEFAULT_EMISSION = new Vec3(0.0f, 0.0f, 0.0f);

  public static final float DEFAULT_SHININESS = 32;

  private Vec3 ambient;
  private Vec3 diffuse;
  private Vec3 specular;
  private Vec3 emission;  // not used in any program or shader, but here for completeness
  private float shininess;
  private Texture diffuseMap;
  private Texture specularMap;
  private Texture emissionMap;  // if emission properties are required, use this

  //...series of constructors

  //...series of set and get methods for the attributes

  //...a clone method
}
```

**Program Listing 7.2:** Material.java

```java
public class MaterialConstants {
  
  // Note: These are final and cannot be changed.

  public static final Material red = new Material(
    new Vec3(0.3f,0,0),new Vec3(1,0,0));
    
  public static final Material green = new Material(
    new Vec3(0,0.3f,0),new Vec3(0,1,0));

  public static final Material blue = new Material(
    new Vec3(0,0,0.3f),new Vec3(0,0,1));

  public static final Material dullWhiteLightSource = new Material(
    new Vec3(0.3f,0.3f,0.3f),new Vec3(0.7f,0.7f,0.7f),
    new Vec3(1,1,1),32);

  public static final Material brightWhiteLightSource = new Material(
    new Vec3(1,1,1),new Vec3(1,1,1),
    new Vec3(1,1,1),new Vec3(0.5f,0.5f,0.5f), 32);

  //...further declarations
}
```

**Program Listing 7.3:** MaterialConstants.java

Program Listing 7.4 shows the render method which makes use of two helper methods to render the cube and the light. We'll focus on renderCube.

```java
public void render(GL3 gl) {
  gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);

  lightPosition = getLightPosition();  // changing light position each frame

  Mat4 projectionMatrix = camera.getPerspectiveMatrix();
  Mat4 viewMatrix = camera.getViewMatrix();

  renderLight(gl, shaderLight, getLightModelMatrix(), viewMatrix, projectionMatrix);
  renderCube(gl, shaderCube, getCubeModelMatrix(), viewMatrix, projectionMatrix);
}
```

**Program Listing 7.4:** Rendering the light and the cube.


```java
private void renderCube(GL3 gl, Shader shader, Mat4 modelMatrix, Mat4 viewMatrix, Mat4 projectionMatrix) {
  Mat4 mvpMatrix = Mat4.multiply(projectionMatrix, Mat4.multiply(viewMatrix, modelMatrix));
  
  shader.use(gl);

  shader.setFloatArray(gl, "model", modelMatrix.toFloatArrayForGLSL());
  shader.setFloatArray(gl, "mvpMatrix", mvpMatrix.toFloatArrayForGLSL());
  
  shader.setVec3(gl, "viewPos", camera.getPosition());

  shader.setVec3(gl, "light.position", lightPosition);
  shader.setVec3(gl, "light.ambient", lightMaterial.getAmbient());
  shader.setVec3(gl, "light.diffuse", lightMaterial.getDiffuse());
  shader.setVec3(gl, "light.specular", lightMaterial.getSpecular());

  shader.setVec3(gl, "material.ambient", cubeMaterial.getAmbient());
  shader.setVec3(gl, "material.diffuse", cubeMaterial.getDiffuse());
  shader.setVec3(gl, "material.specular", cubeMaterial.getSpecular());
  shader.setFloat(gl, "material.shininess", cubeMaterial.getShininess());

  cube.render(gl);
}
```

**Program Listing 7.5:** Rendering the cube.

Program Listing 7.5 shows the method to render a cube which makes use of the Material instances for the cube and the light to set the relevant shader values.

Program Listing 7.6 deals with the light. Here, we can see that the colour that will be used to render the light mesh is the diffuse value of the light's material properties.

```java
private void renderLight(GL3 gl, Shader shader, Mat4 modelMatrix, Mat4 view, Mat4 projection) {
  Mat4 mvpMatrix = Mat4.multiply(projection, Mat4.multiply(view, modelMatrix));
  
  shader.use(gl);
  shader.setFloatArray(gl, "model", modelMatrix.toFloatArrayForGLSL());
  shader.setFloatArray(gl, "mvpMatrix", mvpMatrix.toFloatArrayForGLSL());

  shader.setVec3(gl, "lightColor", lightMaterial.getDiffuse());

  light.render(gl);
}
```

**Program Listing 7.6:** Rendering the light.


---


## MCQs (written in collaboration with Google Gemini)

<p>1. What is the main purpose of the new Material class introduced in this program?</p>
<details>
<summary>a) To combine the vertex and index data for a mesh into a single object.</summary>
<p><b>Incorrect.</b> The Mesh class already handles the vertex and index data. The Material class manages properties for lighting and color.</p>
</details>
<details>
<summary>b) To encapsulate all the material properties, such as ambient, diffuse, specular, and shininess, into a single object.</summary>
<p><b>Correct.</b> The text states the aim is to "move all the attributes related to the material properties of an object into a separate Material class." This simplifies the code by centralizing these attributes.</p>
</details>
<details>
<summary>c) To create new mesh geometry for objects like cubes and spheres.</summary>
<p><b>Incorrect.</b> The Mesh class and separate Cube and Sphere classes are responsible for geometry. The Material class deals with lighting and visual properties.</p>
</details>
<details>
<summary>d) To directly render an object with its associated lighting properties.</summary>
<p><b>Incorrect.</b> The renderCube and renderLight methods handle the rendering process. They use the Material instances to set shader values, but the Material class itself doesn't render anything.</p>
</details>
<br>
<p>2. Why does the program use MaterialConstants.dullWhiteLightSource.clone() to create a lightMaterial instance?</p>
<details>
<summary>a) Because the dullWhiteLightSource is a final static constant and cannot be directly changed.</summary>
<p><b>Correct.</b> Program Listing 7.3 notes that the materials in the MaterialConstants class are "final and cannot be changed." Therefore, a clone is necessary to create a new, modifiable instance for lightMaterial.</p>
</details>
<details>
<summary>b) To save memory by using a reference to the constant instance instead of creating a new object.</summary>
<p><b>Incorrect.</b> clone() creates a new, separate instance in memory, which is the opposite of a simple reference.</p>
</details>
<details>
<summary>c) To copy all the light's material attributes into a single new object.</summary>
<p><b>Incorrect.</b> While clone() does this, the primary reason for using it here is to get a modifiable copy of a final constant, which is a key concept highlighted in the text.</p>
</details>
<details>
<summary>d) To ensure that the light always has a dull white color.</summary>
<p><b>Incorrect.</b> The use of clone() implies the material can be changed later. If the color was meant to be fixed, a direct reference would suffice.</p>
</details>

---

## Exercises

1. ???

[back](ch7.md) | [main menu](../README.md)