[back](ch8.md) | [main menu](../README.md)
 
## 8.3 More scenes

### 8.3.1 Three objects

Program: ch8_3_F\SG03.java

This example is a scene of three objects, as illustrated in Figure 8.5. The scene graph classes introduced in section 8.2 are used again.

<p align="center">
  <img src="ch8_img/ch8_3_F.png" alt="three objects" width="200"><br>
  <strong>Figure 8.5:</strong> A scene containing three objects.
</p>

Program Listing 8.8 sets up the class attributes for the scene and creates the textures and light and makes the pieces with some helper classes. cubeLower and cubeUpper will be joined together with a scene graph. fStemCube, fTopCube and fMiddleCube will be joined together using another scene graph.

```java
private Model floor, cubeLower, cubeUpper, sphere, fStemCube, fTopCube, fMiddleCube;
private Light light;
private SGNode cuboidsRoot, fShapeRoot;

// textures
private TextureLibrary textures;


public void initialise(GL3 gl) {
  // create textures

  // create light

  floor = makeFloor(gl, getM1(), "assets/shaders/fs_standard_d.txt", textures.get("chequerboard"), null, null);
  
  Material materialCube = MaterialConstants.green.clone();
  cubeLower = makeCube(gl, new Mat4(1), materialCube,
                      "assets/shaders/fs_standard_0t.txt", 
                      null,null,null);

  materialCube = MaterialConstants.red.clone();
  cubeUpper = makeCube(gl, new Mat4(1), materialCube,
                      "assets/shaders/fs_standard_0t.txt", 
                      null,null,null);

  materialCube = MaterialConstants.blue.clone();
  fStemCube = makeCube(gl, new Mat4(1), materialCube,
                      "assets/shaders/fs_standard_0t.txt", 
                      null,null,null);

  fTopCube = makeCube(gl, new Mat4(1), materialCube,
                      "assets/shaders/fs_standard_0t.txt", 
                      null,null,null);

  fMiddleCube = makeCube(gl, new Mat4(1), materialCube,
                      "assets/shaders/fs_standard_0t.txt", 
                      null,null,null);

  Mat4 mSphere = Mat4Transform.translate(0,0.5f,0);
  mSphere = Mat4.multiply(Mat4Transform.scale(2,4,2),mSphere);
  sphere = makeSphere(gl, mSphere,
                      "assets/shaders/fs_standard_d.txt", 
                      textures.get("cloud"), null, null);


  // now do the scene graphs

}
```

Program Listing 8.8: ??????????????????

Program Listing 8.9 joins two cubes together into a scene graph with root called cuboidsRoot. One cube is stacked on top of the other. Again, certain literals could be replaced by variables to make the program more flexible.

```java
// ...

public void initialise(GL3 gl) {
  // ...

  // cuboids
  cuboidsRoot = new SGNameNode("two-cuboid structure");
  SGTransformNode translateInPlane = new SGTransformNode("translate(1.7,0,1.3)",Mat4Transform.translate(2.7f, 0f, 2.3f));
  SGNameNode lowerCuboid = new SGNameNode("lower cuboid");
  Mat4 m = Mat4Transform.scale(1,1,1);
  m = Mat4.multiply(m, Mat4Transform.translate(0,0.5f,0));
  SGTransformNode lowerCubeTransform = new SGTransformNode("some transforms", m);
  SGModelNode lowerCubeShape = new SGModelNode("cubeLower", cubeLower);
  SGTransformNode translateToTop = new SGTransformNode("translate(0,4,0)",Mat4Transform.translate(0,0,0));
  SGNameNode upperCuboid = new SGNameNode("upper cuboid");
  m = Mat4Transform.scale(0.6f,3.5f,0.6f);
  m = Mat4.multiply(m, Mat4Transform.translate(0,0.5f,0));
  SGTransformNode upperCubeTransform = new SGTransformNode("some transforms", m);
  SGModelNode upperCubeShape = new SGModelNode("cubeUpper", cubeUpper);

  cuboidsRoot.addChild(translateInPlane);
    translateInPlane.addChild(lowerCuboid);
      lowerCuboid.addChild(lowerCubeTransform);
        lowerCubeTransform.addChild(lowerCubeShape);
      lowerCuboid.addChild(translateToTop);
        translateToTop.addChild(upperCuboid);
          upperCuboid.addChild(upperCubeTransform);
            upperCubeTransform.addChild(upperCubeShape);
    cuboidsRoot.update(); 

  // F shape

}
```

Program Listing 8.9: ??????????????????

Program Listing 8.10 joins three cubes together into a scene graph with root called fShapeRoot. Again, certain literals could be replaced by variables to make the program more flexible.

```java
// ...

public void initialise(GL3 gl) {
  // ...
  // cuboids
  // ...
  // F shape
  fShapeRoot = new SGNameNode("f structure");
  SGTransformNode translateFInPlane = new SGTransformNode("translate(0.2,0,1.7)",Mat4Transform.translate(0.2f,0f,2.7f));

  SGNameNode fStem = new SGNameNode("fStem");
  m = Mat4Transform.scale(0.5f,3,1);
  m = Mat4.multiply(m, Mat4Transform.translate(0,0.5f,0));
  SGTransformNode fStemTransform = new SGTransformNode("some transforms", m);
  SGModelNode fStemShape = new SGModelNode("cubeLower", fStemCube);

  SGNameNode fMiddle = new SGNameNode("fMiddle");
  m = Mat4Transform.translate(0.5f,1f,0);
  m = Mat4.multiply(m, Mat4Transform.scale(1,0.5f,1));
  m = Mat4.multiply(m, Mat4Transform.translate(0,0.5f,0));
  SGTransformNode fMiddleTransform = new SGTransformNode("some transforms", m);
  SGModelNode fMiddleShape = new SGModelNode("cubeLower", fMiddleCube);

  SGNameNode fTop = new SGNameNode("fTop");
  m = Mat4Transform.translate(0.5f,2.5f,0);
  m = Mat4.multiply(m, Mat4Transform.scale(1.5f,0.5f,1));
  m = Mat4.multiply(m, Mat4Transform.translate(0,0.5f,0));
  SGTransformNode fTopTransform = new SGTransformNode("some transforms", m);
  SGModelNode fTopShape = new SGModelNode("cubeLower", fTopCube);

  fShapeRoot.addChild(translateFInPlane);
    translateFInPlane.addChild(fStem);
      fStem.addChild(fStemTransform);
        fStemTransform.addChild(fStemShape);
      fStem.addChild(fMiddle);
        fMiddle.addChild(fMiddleTransform);
          fMiddleTransform.addChild(fMiddleShape);
      fStem.addChild(fTop);
        fTop.addChild(fTopTransform);
          fTopTransform.addChild(fTopShape);
  fShapeRoot.update();

}
```

Program Listing 8.10: ??????????????????

Finally, Program Listing 8.11 renders the scene.

```java
public void render(GL3 gl) {
  gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);

  light.setPosition(getLightPosition()); // changing light position each frame

  light.render(gl);

  floor.render(gl);
  sphere.render(gl);
  
  cuboidsRoot.draw(gl);
  fShapeRoot.draw(gl);
}
```

Program Listing 8.11: ??????????????????

---

### 8.3.2 Controlling relationships between the three objects

Program: ch8_3_F2\SG04.java

This example repeats the scene from the previous section, but adds some extra transformations into the two scene graphs to enable the objects to be controlled from the user interface. Figure 8.6 illustrates this. The F shape can be rotated by 180 degrees around the y axis and the bottom cuboid in the stack of cuboids can be independently rotated about the y axis.

<p align="center">
  <img src="ch8_img/ch8_3_F.png" alt="three objects" width="200">.<img src="ch8_img/ch8_3_F2.png" alt="three objects" width="200"> <br>
  <strong>Figure 8.6:</strong> Interface controls are introduced to allow parts of the scene to be changed.
</p>

Program Listing 8.12 shows the node that need to be introduced into the previous example for the cuboids stack. A rotateAroundY SGTransformNode is created and added in the branch for controlling the lower cuboid only. It does not affect the upperCuboid. Likewise, Program Listing 8.13 shows the node that need to be introduced into the previous example for the F object. Again, a rotateAroundY node is added. This affects every child below it, i.e. all the cubes that are its children, thus the whole F rotates. The two rotateAroundY nodes are actually in different methods in the reformulated program which is why they are called the same name here. You should take some time to study the differences between this program and the previous one to increase your understanding of how scene graphs work.


```java
cuboidsRoot.addChild(translateInPlane);
  translateInPlane.addChild(lowerCuboid);
    lowerCuboid.addChild(rotateAroundY);           // added
      rotateAroundY.addChild(lowerCubeTransform);  // added
      lowerCubeTransform.addChild(lowerCubeShape);
    lowerCuboid.addChild(translateToTop);
      translateToTop.addChild(upperCuboid);
        upperCuboid.addChild(upperCubeTransform);
          upperCubeTransform.addChild(upperCubeShape);
cuboidsRoot.update(); 
```

Program Listing 8.12: ???

```java
fShapeRoot.addChild(translateFInPlane);
  translateFInPlane.addChild(rotateAroundY);  // added
  rotateAroundY.addChild(fStem);              // added
    fStem.addChild(fStemTransform);
      fStemTransform.addChild(fStemShape);
    fStem.addChild(fMiddle);
      fMiddle.addChild(fMiddleTransform);
        fMiddleTransform.addChild(fMiddleShape);
    fStem.addChild(fTop);
      fTop.addChild(fTopTransform);
        fTopTransform.addChild(fTopShape);
fShapeRoot.update();
```

Program Listing 8.13: ???

---

### 8.3.3 Branches that articulate with respect to one another

Program: ch8_6_branches\SG05.java

Figure 8.7 shows the results of this program. It features a lower branch that rotates about the point that touches the floor and an upper branch that rotates about its attachment point with the lower branch. 

<p align="center">
  <img src="ch8_img/ch8_5_branches.png" alt="Articulating branches" width="200"><br>
  <strong>Figure 8.7:</strong> Articulating branches.
</p>

Program Listing 8.14 gives the relevant code. Three SGTransformNodes are declared at the class level, so are then accessible anywhere in the class. Some extra attributes are also declared to keep track of certain values. xPosition stores the current world x position of the base of the two-branch structure. The variables storing rotations are used to rotate either the whole two-branch structure or to rotate the upper branch about its connection to the lower branch. (The lectures will consider this example in detail.)


```java
private Model sphere;
private Model floor;
private Light light;
private SGNode twoBranchRoot;

private SGTransformNode translateX, rotateAll, rotateUpper;
private float xPosition = 0;
private float rotateAllAngleStart = 25, rotateAllAngle = rotateAllAngleStart;
private float rotateUpperAngleStart = -60, rotateUpperAngle = rotateUpperAngleStart;

public void initialise(GL3 gl) {
  createRandomNumbers();

  textures = new TextureLibrary();
  textures.add(gl, "diffuse_container", "assets/textures/container2.jpg");
  textures.add(gl, "specular_container", "assets/textures/container2_specular.jpg");
  textures.add(gl, "chequerboard", "assets/textures/chequerboard.jpg");
  textures.add(gl, "cloud", "assets/textures/cloud.jpg");
  textures.add(gl, "matrix", "assets/textures/matrix.jpg");
  textures.add(gl, "black1x1", "assets/textures/black1x1.jpg");
  textures.add(gl, "white1x1", "assets/textures/white1x1.jpg");

  light = new Light(gl, camera);
  Material m = new Material();
  m.setAmbient(0.3f, 0.3f, 0.3f);
  m.setDiffuse(0.7f, 0.7f, 0.7f);
  m.setSpecular(0.7f, 0.7f, 0.7f);
  light.setMaterial(m);

  floor = makeFloor(gl, "assets/shaders/fs_standard_d.txt", textures.get("chequerboard"), null, null);
  
  sphere = makeSphere(gl, new Mat4(1),
                      "assets/shaders/fs_standard_d.txt", 
                      textures.get("cloud"), null, null);

  twoBranchRoot = new SGNameNode("two-branch structure");

  float lowerBranchHeight = 4f;
  SGNode lowerBranch = makeLowerBranch(sphere, lowerBranchHeight);
  SGNode upperBranch = makeUpperBranch(sphere);
  
  // 1. draw just the lowerBranch
  // twoBranchRoot.addChild(lowerBranch);
  // twoBranchRoot.update();  // IMPORTANT – must be done every time any part of the scene graph changes

  // 2. draw just the upperBranch
  // twoBranchRoot.addChild(upperBranch);
  // twoBranchRoot.update();  // IMPORTANT – must be done every time any part of the scene graph changes

  // 3. draw both branches without any extra transforms to join them
  // result will be only one can be seen as they are both drawn at the origin,
  // so one is inside the other.
  // twoBranchRoot.addChild(lowerBranch);
  //   lowerBranch.addChild(upperBranch);
  // twoBranchRoot.update();  // IMPORTANT – must be done every time any part of the scene graph changes

  // 4. Now join them together with a transform
  // TransformNode translateToTop = new TransformNode("translate(0,4,0)",Mat4Transform.translate(0,4,0));
  // twoBranchRoot.addChild(lowerBranch);
  //   lowerBranch.addChild(translateToTop);
  //     translateToTop.addChild(upperBranch);
  // twoBranchRoot.update();  // IMPORTANT – must be done every time any part of the scene graph changes

  // 5. Now for some animation
  SGTransformNode translateToTop = new SGTransformNode("translate(0,"+lowerBranchHeight+",0)",
                                                    Mat4Transform.translate(0,lowerBranchHeight,0));
  // The next are global variables so they can be updated in other methods
  translateX = new SGTransformNode("translate("+xPosition+",0,0)", Mat4Transform.translate(xPosition,0,0));  
  rotateAll = new SGTransformNode("rotateAroundZ("+rotateAllAngle+")", Mat4Transform.rotateAroundZ(rotateAllAngle));
  rotateUpper = new SGTransformNode("rotateAroundZ("+rotateUpperAngle+")",Mat4Transform.rotateAroundZ(rotateUpperAngle));
  
  twoBranchRoot.addChild(translateX);
    translateX.addChild(rotateAll);
      rotateAll.addChild(lowerBranch);
        lowerBranch.addChild(translateToTop);
          translateToTop.addChild(rotateUpper);
            rotateUpper.addChild(upperBranch);
  twoBranchRoot.update();  // IMPORTANT – must be done every time any part of the scene graph changes
  // end of 5. 

}
```

Program Listing 8.14: ???

Program Listing 8.14 relies on a number of helper methods to make the pieces that are used in the scene graph. The details of these are not shown here. The indentation in the scene graph construction at the end of the method indicates the different levels in the scene graph, with one child per parent.

One aspect to note in Program Listing 8.14 is that there are five numbered parts, four of which are commented out. The fifth part is what currently runs. Each of the numbered parts can be individually uncommented with the others commented to show the different stages of creating the scene. This can be quite a useful way to debug complex scene graphs.

Program Listing 8.15 gives the render method. The method updateBranches() is called before the scene graph, twoBranchRoot, is drawn. Method updateBranches() uses the elapsed system time to create new values for rotateAllAngle and rotateUpperAngle. The relevant TransformNodes in the scene graph are then updated accordingly. (Note: if options 1-4 are being investigated in Program Listing 8.14, then this line of code will need to be commented out, as it only applies for option 5.)

This example illustrates the power of the scene graph in action. By storing references to specific TransformNodes in the scene graph, we can change the transforms stored in them. We then update the scene graph (twoBranchRoot.update()) to update all the world transformations stored in each dependent node, and then the scene graph can be redrawn using the new values.

```java
public void render(GL3 gl) {
  gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);
  light.setPosition(getLightPosition()); // changing light position each frame
  light.render(gl);
  floor.render(gl);
  
// 5. animation. Comment out the following line for 1-4.
  updateBranches();

  twoBranchRoot.draw(gl);
}

private void updateBranches() {
  double elapsedTime = getSeconds()-startTime;
  rotateAllAngle = rotateAllAngleStart*(float)Math.sin(elapsedTime);
  rotateUpperAngle = rotateUpperAngleStart*(float)Math.sin(elapsedTime*0.7f);
  rotateAll.setTransform(Mat4Transform.rotateAroundZ(rotateAllAngle));
  rotateUpper.setTransform(Mat4Transform.rotateAroundZ(rotateUpperAngle));
  twoBranchRoot.update(); // IMPORTANT – the scene graph has changed
}
```

Program Listing 8.15: ???

## Exercises

1. One of the attributes in the class in Program Listing 8.14 is xPosition, which is used in translateX. Add two extra buttons to the main program (SG05.java) to increment and decrement the xPosition value by a certain amount. This will entail adding extra methods to SG05_GLEventListener.java to carry out these actions and redraw the scene.

---

### 8.3.4 Multiple upper branches

Program: ch8_6_more_branches\SG06.java

This example introduces a second upper branch to the previous example. The second upper branch also rotates about its attachment point with the lower branch. Figure 8.8 shows the result.

<p align="center">
  <img src="ch8_img/ch8_6_branches.png" alt="more articulating branches" width="200"> <br>
  <strong>Figure 8.8:</strong> More articulating branches.
</p>

The main difference is shown in Program Listing 8.16. Where the previous example added only a single upper branch to the lower branch, this scene graph hierarchy adds two children to lowerBranch. You should study the rest of this program to make sure you understand the rest of the changes required to control the different branches.

```java
twoBranchRoot.addChild(translateX);
  translateX.addChild(rotateAll);
    rotateAll.addChild(lowerBranch);
      lowerBranch.addChild(translateToTop1);
        translateToTop1.addChild(rotateUpper1);
          rotateUpper1.addChild(upperBranch1);
      lowerBranch.addChild(translateToTop2);     // translateToTop1 could be used here as this is not an animated value
        translateToTop2.addChild(rotateUpper2);  // and here
          rotateUpper2.addChild(upperBranch2);
twoBranchRoot.update();  // IMPORTANT – must be done every time any part of the scene graph changes
```

Program Listing 8.16: ...

---

## MCQs (written in collaboration with Google Gemini)

GLSL???

---

## Exercises

1. ???

[back](ch8.md) | [main menu](../README.md)