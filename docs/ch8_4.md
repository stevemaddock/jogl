[back](ch8.md) | [main menu](../README.md)
 
## 8.4 Robots

### 8.4.1 A robot

Program: ch8_7_robot\SG07.java

Figure 8.9 shows the results from this program. Interface controls are also available to manipulate the arms. 

<p align="center">
  <img src="ch8_img/ch8_7_robot.png" alt="a robot" width="200"><br>
  <strong>Figure 8.9:</strong> A robot.
</p>

As your programs become longer, you should consider the use of separate classes for different objects, e.g. a class for the robot and a class for the room (which in this case is just a floor), and perhaps even a class to handle animation data and control. For this example, a separate class is used for the Robot. This will be useful in the next example we look at.

## Exercises

1. Draw a scene graph for the robot in Figure 8.9. Then, compare your scene graph with the one in the program. 

### 8.4.2 Many robots

Program: ch8_8_robot_many\SG08.java

Figure 8.10 shows the results from this program. Interface controls are available to start and stop the animation. In this example, the robot class has been extended to store its current position. Methods are also available to update teh position and check for collision with the (invisible) walls of the room - in this case, when the edge of the floor is reached, the robot changes direction. 

Multiple instances of the robot class are created and given random movement directions. Program Listing 8.17 gives the code to produce a random movement direction when an instance of the Robot class is created. Program Listing 8.18 is the method in the Robot class that is used to update the position and check for reaching the edge of the floor space. If this happens the movement direction is reflected. 

This extra code was added to the Robot class which already contained methods to update arm angles and x position using other methods. This demonstrates the problems of feature creep by adding to a previous example. This could be organised much better if we had listed the functionality of the robot model in advance of creating it. One option might be to separate out control and update into a separate class, where collisions and collision response could be handled too. I'll leave this to future work.

<p align="center">
  <img src="ch8_img/ch8_8_robot_many.png" alt="many robots" width="200"><br>
  <strong>Figure 8.10:</strong> Many animating robots.
</p>

```java
private Vec3 position = new Vec3(0, 0, 0);
private Vec3 updateDelta = new Vec3((float)(Math.random()*0.1), 0, (float)(Math.random()*0.1));
```

Program Listing 8.17: ???


```java
public void updatePosition(float min, float max) {
  position = Vec3.add(position, updateDelta);
  if (position.x > max || position.x < min) {
    updateDelta.x = -updateDelta.x;
  }
  if (position.z > max || position.z < min) {
    updateDelta.z = -updateDelta.z;
  }
  robotMoveTranslate.setTransform(Mat4Transform.translate(position));
  robotMoveTranslate.update();
}
```

Program Listing 8.18: ???


---

## MCQs (written in collaboration with Google Gemini)

GLSL???

---

## Exercises

1. ???

[back](ch8.md) | [main menu](../README.md)